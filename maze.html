    <!DOCTYPE html>
    <html lang="en">
    <head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Maze Auto-move Final</title>
    <style>
html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    color: #fff;
    font-family: sans-serif;
}

body {
    touch-action: none;
}

canvas {
    width: 90vw;
    height: auto;
    max-width: 744px;
    display: block;
    background: #000;
    margin-top: 10px;
}

#title {
    font-size: 24px;
    font-weight: bold;
    margin-top: 10px;
}

#timer {
    font-size: 20px;
    margin-top: 4px;
}

#winMessage, #loseMessage {
    font-size: 32px;
    font-weight: bold;
    text-align: center;
    text-shadow: 0 0 10px #000;
    background: rgba(0, 0, 0, 0.75);
    padding: 20px 30px;
    border-radius: 14px;
    position: fixed;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 2000;
}

#winMessage {
    color: #00ff9c;
    text-shadow: 0 0 12px #00ff9c;
}

#loseMessage {
    color: #ff4444;
    text-shadow: 0 0 12px #ff0000;
}

#controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 20px;
    z-index: 1000;
}

#dpad {
    display: grid;
    grid-template-columns: 60px 60px 60px;
    grid-template-rows: 60px 60px 60px;
    gap: 10px;
}

.center-gap {
    width: 60px;
    height: 60px;
}

#dpad button, #undoBtn {
    width: 60px;
    height: 60px;
    font-size: 30px;
    background-color: #333;
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
}

#dpad button:hover, #undoBtn:hover {
    background-color: #555;
}

/* ·∫®n c√°c ƒëi·ªÅu khi·ªÉn tr√™n PC */
@media (min-width: 769px) {
    #controls {
        display: none;
    }
}

@media (min-width: 769px) {
    #controls {
        display: flex;
        bottom: 20px;
        left: auto;
        right: 20px;
        transform: none;
    }

    #dpad {
        display: none; /* ·∫®n 4 n√∫t di chuy·ªÉn */
    }

    #undoBtn {
        position: static;
    }
}

    </style>
    </head>

    <body>
    <div id="title">H√£y ki√™n nh·∫´n v√† c·∫ßu may</div>
    <div id="timer">Time: 90</div>
    <canvas id="mazeCanvas"></canvas>
  
    <div id="winMessage" style="display:none;">
    üéâ Ch√∫c m·ª´ng h·∫øt m√™ m·ª•i! üéâ
</div>

<div id="loseMessage" style="display:none;">
    üíÄ B·∫°n ƒë√£ h·∫øt th·ªùi gian! üíÄ
</div>
 <!-- C√°c n√∫t di chuy·ªÉn (hi·ªÉn th·ªã ch·ªâ tr√™n mobile) -->
    <div id="controls">
  <div id="dpad">
    <div></div>
    <button id="upBtn">‚Üë</button>
    <div></div>

    <button id="leftBtn">‚Üê</button>
    <div class="center-gap"></div>
    <button id="rightBtn">‚Üí</button>

    <div></div>
    <button id="downBtn">‚Üì</button>
    <div></div>
  </div>

  <button id="undoBtn">‚ü≥</button>
</div>

    <script>
    const canvas = document.getElementById("mazeCanvas");
    const ctx = canvas.getContext("2d");

    const ROWS = 33;
    const COLS = 33;
    const TILE = 24;
    canvas.width = COLS * TILE;
    canvas.height = ROWS * TILE;

    let maze = [];
    let player = {x:0, y:0};
    let exit = {x:COLS-1, y:ROWS-1};
    let prevPos = null;
    let revealExit = true;
    let timerEl = document.getElementById("timer");
    let messageEl = document.getElementById("message");

    let timeLeft = 90; // 90 gi√¢y
    let timerInterval;
let timerStarted = false;
let revealAll = false;

// === CH·ªêNG D√çNH 2 √î ===
function countOpenNeighbors(x,y){
    let c = 0;
    for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
        let nx = x+dx, ny = y+dy;
        if(inBounds(nx,ny) && maze[ny][nx]===0) c++;
    }
    return c;
}
// === N·ªêI DEAD-END G·∫¶N EXIT V√ÄO NH√ÅNH GI·∫¢ ===
function connectLonelyNearExit(){
    const MAX_DIST = 5;
    let candidates = [];

    for(let y=exit.y-MAX_DIST; y<=exit.y+MAX_DIST; y++){
        for(let x=exit.x-MAX_DIST; x<=exit.x+MAX_DIST; x++){
            if(!inBounds(x,y)) continue;
            if(maze[y][x]!==0) continue;

            if(countOpenNeighbors(x,y) !== 1) continue; // ch·ªâ dead-end th·∫≠t

            // ‚≠ê ki·ªÉm tra: n·∫øu dead-end ngay s√°t exit, b·ªè qua
            if(Math.abs(x-exit.x)+Math.abs(y-exit.y) <= 2) continue;
            // ‚ùå n·∫øu dead-end qu√° s√¢u th√¨ b·ªè lu√¥n
            if(getDeadEndDepth(x,y) > 4) continue;
            candidates.push({x,y});
        }
    }

    if(!candidates.length) return;

    let dead = shuffle(candidates)[0];

    for(let [dx,dy] of shuffle([[0,-1],[1,0],[0,1],[-1,0]])){
        let bx = dead.x + dx*2;
        let by = dead.y + dy*2;

        if(!inBounds(bx,by)) continue;
        if(maze[by][bx]!==0) continue;

        // tr√°nh ƒë·ª•ng exit tr·ª±c ti·∫øp
        if(Math.abs(bx-exit.x)+Math.abs(by-exit.y) <= 1) continue;

        if(countOpenNeighbors(dead.x+dx, dead.y+dy)===0){
           if(safeBreakWall(dead.x+dx, dead.y+dy, dead.x, dead.y)){
    break;
}

        }
    }
}

    /* ===== MAZE GEN ===== */
 function initMaze() {
    // B∆∞·ªõc 1: Kh·ªüi t·∫°o m√™ cung ban ƒë·∫ßu
    maze = Array.from({ length: ROWS }, () => Array(COLS).fill(1));

    exit = getFixedExit();
    player = { x: 0, y: 0 };

    carveMainPath(0, 0);
    
    // ‚úÖ G·ªçi h√†m t·∫°o nh√°nh gi·∫£ v√† k·∫øt n·ªëi n√≥ v√†o ƒë∆∞·ªùng ch√≠nh
    for (let y = 1; y < ROWS; y += 2) {
        for (let x = 1; x < COLS; x += 2) {
            if (maze[y][x] === 0) {
                let distToExit = Math.abs(x - exit.x) + Math.abs(y - exit.y);
                if (Math.abs(x - exit.x) + Math.abs(y - exit.y) > 2) {
                // ‚ùå qu√° g·∫ßn exit th√¨ KH√îNG t·∫°o dead-end
                if (distToExit < 6) continue;

                if (Math.random() < 0.35) {
                    // Thay v√¨ addDeadEnds, t·∫°o v√† k·∫øt n·ªëi nh√°nh gi·∫£
                    createFakeDeadEndWithConnection(x, y, 9 + Math.floor(Math.random() * 4));
                }
            }
        }
        }
    }

    // ==== N·ªêI NH√ÅNH GI·∫¢ TR·ª∞C TI·∫æP V√ÄO ƒê∆Ø·ªúNG CH√çNH ====
    let mainPath = getPathFromStartToExit();
if (mainPath.length >= 6) {
    // Gi·∫£m kho·∫£ng c√°ch gi·ªØa c√°c ƒëi·ªÉm n·ªëi v√† tƒÉng kh·∫£ nƒÉng t·∫°o th√™m nh√°nh
    let fractions = [1/52, 2/52, 3/52, 4/52, 5/52, 6/52, 7/52, 4/26, 9/52, 5/26, 6/26, 13/52, 7/26, 8/26, 9/26, 10/26, 11/26, 12/26, 13/26, 14/26, 15/26, 16/26, 17/26, 18/26, 19/26,20/26,21/26,22/26,23/26];
    let indices = fractions.map(f => Math.floor(mainPath.length * f));

    for (let idx of indices) {
        let p = mainPath[idx];

        // ‚úÖ Tr√°nh n·ªëi qu√° g·∫ßn exit
        let distToExit = Math.abs(p.x - exit.x) + Math.abs(p.y - exit.y);
        if (distToExit < 6) continue; 

        // T√¨m √¥ nh√°nh gi·∫£ dead-end xung quanh
        let neighbors = shuffle([[0,-1],[1,0],[0,1],[-1,0]]);
        for (let [dx, dy] of neighbors) {
            let nx = p.x + dx;
            let ny = p.y + dy;
            if (!inBounds(nx, ny)) continue;
            if (maze[ny][nx] !== 0) continue; // ph·∫£i l√† nh√°nh gi·∫£
            if (countOpenNeighbors(nx, ny) !== 1) continue; // dead-end th·∫≠t

            // Th·ª≠ t·∫°o th√™m nhi·ªÅu ng√£ ba ·ªü ƒëi·ªÉm n√†y
            if (countOpenNeighbors(p.x, p.y) < 3) {  // N·∫øu kh√¥ng ph·∫£i ng√£ ba, t·∫°o th√™m ng√£ ba
                // T·∫°o ng√£ ba m·ªõi (th√™m m·ªôt nh√°nh gi·∫£ v√†o ƒëi·ªÉm n√†y)
                let newDirection = shuffle([[0, -1], [1, 0], [0, 1], [-1, 0]])[0];
                let nx2 = p.x + newDirection[0];
                let ny2 = p.y + newDirection[1];
                if (inBounds(nx2, ny2) && maze[ny2][nx2] === 1) {
                    safeBreakWall(nx2, ny2, p.x, p.y);  // ƒê·ª•c t·∫°o th√™m ng√£ ba
                }
            }

            // ƒê·ª•c 1 √¥ n·ªëi nh√°nh gi·∫£ v√†o ƒë∆∞·ªùng ch√≠nh
            if (safeBreakWall(p.x + dx, p.y + dy, p.x, p.y)) {
                break; // m·ªói v·ªã tr√≠ ch·ªâ n·ªëi 1 nh√°nh
            }
        }
    }
}

    // ==== K·∫øt n·ªëi nh√°nh gi·∫£ v√†o ƒë∆∞·ªùng ch√≠nh ====
    connectFakeBranchesAlongMainPath();
    connectSomeFakeBranchesToMainPath();
    breakWallsNearFakeBranches();
    ensureJunctionEveryNCells();
    
    // üî• QUAN TR·ªåNG: ƒê·∫£m b·∫£o m√™ cung c√≥ l·ªëi ra h·ª£p l·ªá
    sealExit();
    createFakeBranchAndConnect();
    connectLonelyNearExit();
    ensureExitReachable_FarthestFromExit();

    // ƒê·∫£m b·∫£o l·ªëi ra cho player
    maze[0][0] = 0;
    maze[0][1] = 0;
    maze[1][0] = 0;

    maze[exit.y][exit.x] = 0;

    // ‚úÖ Ch·ªânh s·ª≠a v√πng c√¥ l·∫≠p
    let safety = 300;
    while (safety--) {
        let fixed = ensureAllPathsReachable();
        if (!fixed) break;

        // Ph√° b·ªõt t∆∞·ªùng d√†i > 20
        for (let y = 1; y < ROWS - 1; y++) {
            for (let x = 1; x < COLS - 1; x++) {
                if (maze[y][x] === 1) {
                    let len = 0;
                    for (let k = x; k < COLS - 1 && maze[y][k] === 1; k++) len++;
                    if (len > 12) maze[y][x + Math.floor(len / 2)] = 0;
                }
            }
        }
    }

    fixAllIsolatedPaths();
    enforceSingleExitEntrance();
    drawMaze();
}

 function getFixedExit(){
    return {
        x: COLS - 3, // c√°ch t∆∞·ªùng ph·∫£i 2 √¥
        y: ROWS - 3  // c√°ch t∆∞·ªùng d∆∞·ªõi 2 √¥
    };
}
function shuffle(arr){
    return arr.sort(()=>Math.random()-0.5);
}

function inBounds(x,y){
    return x>=0 && y>=0 && x<COLS && y<ROWS;
}
function carveMainPath(x, y, depth = 0){
    maze[y][x] = 0;

    let dirs = shuffle([
        [0,-1],[1,0],[0,1],[-1,0]
    ]);

    for(let [dx,dy] of dirs){
        let nx = x + dx*2;
        let ny = y + dy*2;

        if(!inBounds(nx,ny)) continue;
        if(maze[ny][nx] === 0) continue;

        // ‚ùå tr√°nh ƒë√†o th·∫≥ng v·ªÅ exit s·ªõm
        let distToExit = Math.abs(nx-exit.x)+Math.abs(ny-exit.y);
        if(distToExit < 10 && depth < 20) continue;

        maze[y+dy][x+dx] = 0;
        carveMainPath(nx,ny,depth+1);
    }
}
function carveDeadEnd(x,y,length=9){
    length = Math.min(length, 12); 
    let cx=x, cy=y;
    let dir = shuffle([[0,-1],[1,0],[0,1],[-1,0]])[0];

    for(let i=0;i<length;i++){
        let nx=cx+dir[0]*2;
        let ny=cy+dir[1]*2;

        if(!inBounds(nx,ny) || maze[ny][nx]===0) break;
        if(countOpenNeighbors(nx,ny) > 1) break; 

        safeBreakWall(cx+dir[0], cy+dir[1]);
        safeBreakWall(nx, ny);

        cx=nx; cy=ny;
    }

    // üî• M·ªöI: ƒë·ª•c n·ªëi nh√°nh gi·∫£ n√†y v√†o ƒë∆∞·ªùng ch√≠nh ngay l·∫≠p t·ª©c
    let path = getPathFromStartToExit();
    for(let p of path){
        if(Math.abs(p.x - cx)+Math.abs(p.y - cy) === 2){ // √¥ k·ªÅ ƒë∆∞·ªùng ch√≠nh
            let wx = (p.x + cx) / 2;
            let wy = (p.y + cy) / 2;
            safeBreakWall(wx, wy, cx, cy); // ƒë·ª•c an to√†n
            break;
        }
    }
}

function addDeadEnds(){
    for(let y=1;y<ROWS;y+=2){
        for(let x=1;x<COLS;x+=2){
            if(maze[y][x]!==0) continue;

            let distToExit = Math.abs(x-exit.x) + Math.abs(y-exit.y);

            // ‚ùå qu√° g·∫ßn exit th√¨ KH√îNG t·∫°o dead-end
            if(distToExit < 8) continue;

            if(Math.random() < 0.35){
                carveDeadEnd(x,y,9+Math.floor(Math.random()*4));
            }
        }
    }
}

function getAllDeadEnds(){
    let list = [];
    for(let y=1;y<ROWS-1;y++){
        for(let x=1;x<COLS-1;x++){
            if(maze[y][x]===0 && countOpenNeighbors(x,y)===1){
                list.push({x,y});
            }
        }
    }
    return list;
}
function connectFakeBranchesTogether(){
    let deadEnds = shuffle(getAllDeadEnds());
    let maxLinks = Math.floor(deadEnds.length * 0.35);
    let links = 0;

    for(let d of deadEnds){
        if(links >= maxLinks) break;

        for(let [dx,dy] of shuffle([[0,-1],[1,0],[0,1],[-1,0]])){
            let wx = d.x + dx;
            let wy = d.y + dy;
            let ax = wx + dx;
            let ay = wy + dy;

            if(!inBounds(ax,ay)) continue;
            if(maze[wy][wx] !== 1) continue;

            // ‚≠ê QUAN TR·ªåNG: 2 ƒë·∫ßu ƒë·ªÅu l√† ƒë∆∞·ªùng
            if(maze[d.y][d.x] === 0 && maze[ay][ax] === 0){
                // tr√°nh t·∫°o ng√£ 4
                if(countOpenNeighbors(wx,wy) === 0){
   
                       maze[wy][wx] = 0;

}

                    links++;
                    break;
                }
            }
        }
    }

function connectSomeFakeBranchesToMainPath(){
    let path = getPathFromStartToExit();
    let deadEnds = shuffle(getAllDeadEnds());

    let maxConnect = Math.floor(deadEnds.length * 0.3);
    let connected = 0;

    for(let d of deadEnds){
        if(connected >= maxConnect) break;

        for(let p of path){
            let dx = p.x - d.x;
            let dy = p.y - d.y;

            if(Math.abs(dx)+Math.abs(dy) !== 2) continue;

            let wx = d.x + Math.sign(dx);
            let wy = d.y + Math.sign(dy);

            if(!inBounds(wx,wy)) continue;
            if(maze[wy][wx] !== 1) continue;

            // ‚≠ê 2 ƒë·∫ßu l√† ƒë∆∞·ªùng
            if(maze[d.y][d.x] === 0 && maze[p.y][p.x] === 0){
                if(countOpenNeighbors(wx,wy) === 0){
                    if(safeBreakWall(wx, wy, p.x, p.y)){
    connected++;
    break;
}
                }
            }
        }
    }
}

function sealExit() {
    let ex = exit.x;
    let ey = exit.y;
    const neighbors = [[0,-1], [1,0], [0,1], [-1,0]];

    // 1Ô∏è‚É£ ƒê·∫∑t t∆∞·ªùng 1 √¥ quanh exit
    for (let [dx, dy] of neighbors) {
        let x = ex + dx;
        let y = ey + dy;
        if (inBounds(x, y)) maze[y][x] = 1;
    }

    // 2Ô∏è‚É£ T·∫°o l·ªëi d·∫´n v√†o exit √≠t nh·∫•t 4 √¥, quanh co
    const minLength = 4;
    let pathMade = false;
    let attempts = 0;

    while (!pathMade && attempts < 20) { // gi·ªõi h·∫°n s·ªë l·∫ßn th·ª≠ tr√°nh loop v√¥ h·∫°n
        attempts++;
        // Ch·ªçn h∆∞·ªõng ch√≠nh ng·∫´u nhi√™n
        let [dx, dy] = neighbors[Math.floor(Math.random() * neighbors.length)];
        let length = minLength + Math.floor(Math.random() * 3); // d√†i 4~6 √¥

        let x = ex;
        let y = ey;
        let valid = true;
        let positions = [];

        for (let i = 1; i <= length; i++) {
            x += dx;
            y += dy;
            // C√≥ th·ªÉ th√™m "quanh co" ng·∫´u nhi√™n
            if (Math.random() < 0.3) {
                let turn = neighbors[Math.floor(Math.random() * neighbors.length)];
                x += turn[0];
                y += turn[1];
            }

            if (!inBounds(x, y) || maze[y][x] !== 1) {
                valid = false;
                break;
            }
            if (wouldCreateWidePath(x, y)) {
    valid = false;
    break;
}
            positions.push([x, y]);
        }

        if (valid) {
            for (let [px, py] of positions) maze[py][px] = 0;
            maze[ey][ex] = 0;
            pathMade = true;
        }
    }

    // 3Ô∏è‚É£ B·∫£o hi·ªÉm exit lu√¥n m·ªü
    maze[exit.y][exit.x] = 0;
}

function createFakeDeadEnd(sx, sy, length){
    length = Math.min(length, 8); // nh√°nh gi·∫£ ng·∫Øn
    const dirs = shuffle([[0,-1],[1,0],[0,1],[-1,0]]);

    for(let [dx,dy] of dirs){
        let bx = sx + dx*2;
        let by = sy + dy*2;

        if(!inBounds(bx,by)) continue;
        if(maze[by][bx]===0) continue;
        if(countOpenNeighbors(bx,by)>0) continue;

        // ‚≠ê ch·ªâ 1 choke point
        safeBreakWall(sx+dx, sy+dy);
        safeBreakWall(bx, by);

        let cx=bx, cy=by;
        for(let i=0;i<length;i++){
            let d2 = shuffle([[0,-1],[1,0],[0,1],[-1,0]])[0];
            let nx=cx+d2[0]*2;
            let ny=cy+d2[1]*2;

            if(!inBounds(nx,ny)) break;
            if(maze[ny][nx]===0) break;
            if(countOpenNeighbors(nx,ny)>1) break;

            safeBreakWall(cx+d2[0], cy+d2[1]);
            safeBreakWall(nx, ny);
            cx=nx; cy=ny;
        }
        break; // ‚ùó ch·ªâ 1 nh√°nh
    }
}
function createFakeDeadEndWithConnection(sx, sy, length) {
    // 1Ô∏è‚É£ T·∫°o nh√°nh gi·∫£ nh∆∞ b√¨nh th∆∞·ªùng
    createFakeDeadEnd(sx, sy, length);

    // 2Ô∏è‚É£ N·ªëi nh√°nh gi·∫£ v√†o ƒë∆∞·ªùng ch√≠nh g·∫ßn nh·∫•t
    let path = getPathFromStartToExit();
    let deadEndCells = [{x: sx, y: sy}];

    // L·∫•y c√°c √¥ cu·ªëi nh√°nh gi·∫£ (dead-end th·∫≠t)
    let cx = sx, cy = sy;
    for(let i=0; i<length; i++){
        let dirs = shuffle([[0,-1],[1,0],[0,1],[-1,0]]);
        let found = false;
        for(let [dx,dy] of dirs){
            let nx = cx + dx*2;
            let ny = cy + dy*2;
            if(!inBounds(nx,ny)) continue;
            if(maze[ny][nx] !== 0) continue;
            if(countOpenNeighbors(nx,ny) === 1){
                deadEndCells.push({x:nx,y:nx});
                cx = nx; cy = ny;
                found = true;
                break;
            }
        }
        if(!found) break;
    }

    // 3Ô∏è‚É£ T√¨m √¥ ƒë∆∞·ªùng ch√≠nh g·∫ßn dead-end nh·∫•t
    let best = null;
    let minDist = Infinity;
    for(let d of deadEndCells){
        for(let p of path){
            let dist = Math.abs(d.x - p.x) + Math.abs(d.y - p.y);
            if(dist < minDist && dist > 1){ // tr√°nh qu√° s√°t
                minDist = dist;
                best = {dx: d.x, dy: d.y, px: p.x, py: p.y};
            }
        }
    }

    // 4Ô∏è‚É£ ƒê·ª•c l·ªëi n·ªëi t·ª´ dead-end v√†o ƒë∆∞·ªùng ch√≠nh
    if(best){
        connectBranches(best.dx, best.dy, best.px, best.py);
    }
}

// H√†m l·∫•y m·∫£ng c√°c √¥ ƒë∆∞·ªùng ch√≠nh t·ª´ player ‚Üí exit
function getPathFromStartToExit(){
    // BFS ho·∫∑c DFS ƒë·ªÉ t√¨m 1 ƒë∆∞·ªùng ƒë∆°n gi·∫£n t·ª´ start ‚Üí exit
    let queue = [{x:0,y:0,path:[{x:0,y:0}]}];
    let visited = Array.from({length:ROWS},()=>Array(COLS).fill(false));
    visited[0][0]=true;

    while(queue.length){
        let curr = queue.shift();
        if(curr.x===exit.x && curr.y===exit.y) return curr.path;

        for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
            let nx = curr.x + dx;
            let ny = curr.y + dy;
            if(!inBounds(nx,ny)) continue;
            if(maze[ny][nx]!==0) continue;
            if(visited[ny][nx]) continue;
            visited[ny][nx]=true;
            queue.push({x:nx,y:ny,path:[...curr.path,{x:nx,y:ny}]});
        }
    }
    return [{x:0,y:0}]; // fallback
}

function getReachableFromPlayer(){
    let visited = Array.from({length: ROWS}, () => Array(COLS).fill(false));
    let stack = [{x:0,y:0}];
    visited[0][0] = true;

    while(stack.length){
        let {x,y} = stack.pop();
        for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
            let nx = x+dx, ny = y+dy;
            if(
                inBounds(nx,ny) &&
                !visited[ny][nx] &&
                maze[ny][nx] === 0
            ){
                visited[ny][nx] = true;
                stack.push({x:nx,y:ny});
            }
        }
    }
    return visited;
}

function ensureExitReachable_FarthestFromExit(){
    let reachable = getReachableFromPlayer();

    // ‚úÖ ƒê√£ ƒëi ƒë∆∞·ª£c r·ªìi ‚Üí th√¥i
    if(reachable[exit.y][exit.x]) return;

    // ‚úÖ Nh√¨n / ƒëi th·∫≥ng ƒë∆∞·ª£c ‚Üí th√¥i
    if(hasClearPathToExit()) return;

    let best = null;
    let bestDist = -1;

    for(let y=1; y<ROWS-1; y++){
        for(let x=1; x<COLS-1; x++){
            if(maze[y][x] !== 1) continue;

            let hasReachable = false;
            let hasUnreachable = false;

            for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
                let nx = x+dx, ny = y+dy;
                if(!inBounds(nx,ny)) continue;
                if(maze[ny][nx] !== 0) continue;

                if(reachable[ny][nx]) hasReachable = true;
                else hasUnreachable = true;
            }

            if(hasReachable && hasUnreachable){
                let dist = Math.abs(x-exit.x) + Math.abs(y-exit.y);
                if(dist > bestDist){
                    bestDist = dist;
                    best = {x,y};
                }
            }
        }
    }

    if(best){
        safeBreakWall(best.x, best.y);
 // ‚≠ê ch·ªâ l√∫c TH·∫¨T S·ª∞ C·∫¶N
    }
}

function hasClearPathToExit(){
    let x = 0, y = 0;

    // ƒëi ngang tr∆∞·ªõc
    let stepX = exit.x > x ? 1 : -1;
    while(x !== exit.x){
        if(maze[y][x] === 1) return false;
        x += stepX;
    }

    // r·ªìi ƒëi d·ªçc
    let stepY = exit.y > y ? 1 : -1;
    while(y !== exit.y){
        if(maze[y][x] === 1) return false;
        y += stepY;
    }

    return true;
}

function ensureAllPathsReachable(){
    let reachable = getReachableFromPlayer();
    let regions = getUnreachableRegions(reachable);
    if(!regions.length) return false;

    // 1Ô∏è‚É£ ch·ªçn v√πng ch·∫øt xa exit nh·∫•t
    let bestRegion = null;
    let bestRegionDist = -1;

    for(let region of regions){
        let minDist = Infinity;
        for(let c of region){
            let d = Math.abs(c.x-exit.x) + Math.abs(c.y-exit.y);
            if(d < minDist) minDist = d;
        }
        if(minDist > bestRegionDist){
            bestRegionDist = minDist;
            bestRegion = region;
        }
    }

    // s·ªë √¥ reachable hi·ªán t·∫°i
    let beforeCount = 0;
    for(let y=0;y<ROWS;y++)
        for(let x=0;x<COLS;x++)
            if(reachable[y][x]) beforeCount++;

    let bestWall = null;
    let bestWallDist = -1;

    // 2Ô∏è‚É£ th·ª≠ T·∫§T C·∫¢ t∆∞·ªùng bi√™n c·ªßa v√πng ƒë√≥
    for(let c of bestRegion){
        for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
            let wx = c.x+dx;
            let wy = c.y+dy;
            let rx = c.x-dx;
            let ry = c.y-dy;

            if(!inBounds(wx,wy) || !inBounds(rx,ry)) continue;
            if(maze[wy][wx]!==1) continue;
            if(!reachable[ry][rx]) continue;

            // üî¨ gi·∫£ l·∫≠p ƒë·ª•c
            if(!wouldCreateWidePath(wx, wy)){
    maze[wy][wx] = 0;
}

            let testReachable = getReachableFromPlayer();

            let afterCount = 0;
            for(let y=0;y<ROWS;y++)
                for(let x=0;x<COLS;x++)
                    if(testReachable[y][x]) afterCount++;

            // ho√†n t√°c
            maze[wy][wx] = 1;

            // ‚ùå ƒë·ª•c v√¥ nghƒ©a
            if(afterCount <= beforeCount) continue;

            // ‚úÖ ƒë·ª•c c√≥ hi·ªáu qu·∫£
            let dist = Math.abs(wx-exit.x)+Math.abs(wy-exit.y);
            if(dist > bestWallDist){
                bestWallDist = dist;
                bestWall = {x:wx,y:wy};
            }
        }
    }

    // 3Ô∏è‚É£ ch·ªâ ƒë·ª•c khi ch·∫Øc ch·∫Øn n·ªëi v·ªÅ player
    if(bestWall){
        safeBreakWall(bestWall.x, bestWall.y);

        return true;
    }

    return false;
}

function getUnreachableRegions(reachable){
    let visited = Array.from({length:ROWS},()=>Array(COLS).fill(false));
    let regions = [];

    for(let y=1;y<ROWS-1;y++){
        for(let x=1;x<COLS-1;x++){
            if(maze[y][x]!==0) continue;
            if(reachable[y][x]) continue;
            if(visited[y][x]) continue;

            let stack=[{x,y}];
            let cells=[];
            visited[y][x]=true;

            while(stack.length){
                let {x,y}=stack.pop();
                cells.push({x,y});

                for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
                    let nx=x+dx, ny=y+dy;
                    if(!inBounds(nx,ny)) continue;
                    if(visited[ny][nx]) continue;
                    if(maze[ny][nx]!==0) continue;
                    if(reachable[ny][nx]) continue;

                    visited[ny][nx]=true;
                    stack.push({x:nx,y:ny});
                }
            }

            regions.push(cells);
        }
    }
    return regions;
}

function fixAllIsolatedPaths(){
    let safety = 100; // d∆∞ r·∫•t nhi·ªÅu cho 33x33

    while(safety--){

        let reachable = getReachableFromPlayer();
        let hasIsolated = false;

        // ki·ªÉm tra c√≤n √¥ 0 n√†o unreachable kh√¥ng
        for(let y=0;y<ROWS;y++){
            for(let x=0;x<COLS;x++){
                if(maze[y][x] === 0 && !reachable[y][x]){
                    hasIsolated = true;
                    break;
                }
            }
            if(hasIsolated) break;
        }

        // ‚úÖ s·∫°ch ho√†n to√†n
        if(!hasIsolated) return;

        let bestWall = null;
        let bestDist = -1;

        // t√¨m t∆∞·ªùng n·ªëi reachable <-> unreachable
        for(let y=1;y<ROWS-1;y++){
            for(let x=1;x<COLS-1;x++){
                if(maze[y][x] !== 1) continue;

                let r = false, u = false;

                for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
                    let nx = x+dx, ny = y+dy;
                    if(!inBounds(nx,ny)) continue;
                    if(maze[ny][nx] !== 0) continue;

                    if(reachable[ny][nx]) r = true;
                    else u = true;
                }

                if(r && u){
                    let d = Math.abs(x-exit.x) + Math.abs(y-exit.y);
                    if(d > bestDist){
                        bestDist = d;
                        bestWall = {x,y};
                    }
                }
            }
        }

        // üö® kh√¥ng c√≤n t∆∞·ªùng h·ª£p l·ªá (hi·∫øm, nh∆∞ng an to√†n)
        if(!bestWall){
            console.warn("FIX FAILED: still isolated paths");
            return;
        }

        // üî• ƒë·ª•c 1 √¥
        maze[bestWall.y][bestWall.x] = 0;
    }

    console.warn("FIX SAFETY LIMIT HIT");
}
function connectFakeBranchesAlongMainPath(){
    let path = getPathFromStartToExit();
    if(path.length < 4) return;

    let maxConnections = 14;
    let connectionsMade = 0;

    for(let i = 1; i < path.length; i++){
        if(connectionsMade >= maxConnections) break;

        let p = path[i];

        // ‚ùå tr√°nh qu√° g·∫ßn exit
        let distToExit = Math.abs(p.x - exit.x) + Math.abs(p.y - exit.y);
        if(distToExit <= 5) continue;

        for(let [dx,dy] of shuffle([[0,-1],[1,0],[0,1],[-1,0]])){
            let wx = p.x + dx;
            let wy = p.y + dy;
            let ax = wx + dx;
            let ay = wy + dy;

            if(!inBounds(ax,ay)) continue;
            if(maze[wy][wx] !== 1) continue;

            // ‚≠ê ƒê√öNG CHU·∫®N: t∆∞·ªùng n·∫±m gi·ªØa 2 ƒë∆∞·ªùng
            if(maze[p.y][p.x] === 0 && maze[ay][ax] === 0){

                // ‚≠ê ch·ªëng t·∫°o ng√£ 4 / ng√£ 3 gi·∫£
                if(countOpenNeighbors(wx,wy) === 0){
                    if(safeBreakWall(wx, wy, p.x, p.y)){
    connectionsMade++;
    break;
}
                }
            }
        }
    }
}

function breakWallsNearFakeBranches() {
    let path = getPathFromStartToExit();
    let maxIdx = Math.floor(path.length * 2 / 3); // ∆∞u ti√™n start ‚Üí 2/3 ƒë∆∞·ªùng
    let candidates = [];

    for (let i = 0; i < maxIdx; i++) {
        let p = path[i];
        for (let [dx, dy] of [[0, -1], [1, 0], [0, 1], [-1, 0]]) {
            let nx = p.x + dx;
            let ny = p.y + dy;
            let nnx = p.x + dx * 2;
            let nny = p.y + dy * 2;

            if (!inBounds(nx, ny) || !inBounds(nnx, nny)) continue;
            if (maze[ny][nx] !== 1) continue; // ph·∫£i l√† t∆∞·ªùng
            if (maze[nny][nnx] !== 0) continue; // ph·∫£i l√† nh√°nh gi·∫£/dead-end

            candidates.push({ x: nx, y: ny });
        }
    }

    shuffle(candidates);

    let breakCount = 0;
    for (let j = 0; j < candidates.length; j++) {
        if (breakCount >= 6) break; // ch·ªâ t·ªëi ƒëa 4 √¥
        let c = candidates[j];
        // ‚≠ê Ch·ªâ ƒë·ª•c n·∫øu sau khi ƒë·ª•c kh√¥ng t·∫°o ƒë∆∞·ªùng li·ªÅn k·ªÅ nhi·ªÅu √¥
        if (countOpenNeighbors(c.x, c.y) <= 1) {
            if(safeBreakWall(c.x, c.y, p.x, p.y)){
    breakCount++;
}

        }
    }
}

function createFakeBranchNearExit() {
    // V·ªã tr√≠ g√≥c ph·∫£i d∆∞·ªõi c·ªßa Exit
    let fakeBranchStartX = exit.x + 2;
    let fakeBranchStartY = exit.y + 2;

    // ƒê·∫£m b·∫£o r·∫±ng v·ªã tr√≠ n√†y l√† h·ª£p l·ªá v√† l√† t∆∞·ªùng
    if (inBounds(fakeBranchStartX, fakeBranchStartY) && maze[fakeBranchStartY][fakeBranchStartX] === 1) {
        // T·∫°o nh√°nh gi·∫£ t·∫°i ƒë√¢y (d√†i 6 √¥)
        carveDeadEnd(fakeBranchStartX, fakeBranchStartY, 6); // D√†i 6 √¥

        // Sau khi t·∫°o nh√°nh gi·∫£, k·∫øt n·ªëi n√≥ v·ªõi m·ªôt nh√°nh gi·∫£ kh√°c
        connectToOtherFakeBranch(fakeBranchStartX, fakeBranchStartY);
    }
}
//3 function nh√°nh gi·∫£ g·∫ßn Exit connectToOtherFakeBranch findOtherFakeBranches connectBranches
function connectToOtherFakeBranch(startX, startY) {
    // T√¨m m·ªôt nh√°nh gi·∫£ kh√°c ·ªü v·ªã tr√≠ xa h∆°n Exit (n·∫±m trong ph·∫°m vi m√™ cung)
    let fakeBranches = findOtherFakeBranches();

    // N·∫øu c√≥ nh√°nh gi·∫£ kh√°c, n·ªëi nh√°nh m·ªõi v√†o ƒë√≥
    for (let branch of fakeBranches) {
        let branchX = branch.x;
        let branchY = branch.y;

        // ƒê·∫£m b·∫£o v·ªã tr√≠ nh√°nh gi·∫£ c√≥ th·ªÉ k·∫øt n·ªëi ƒë∆∞·ª£c (v·ªã tr√≠ h·ª£p l·ªá)
        if (inBounds(branchX, branchY) && maze[branchY][branchX] === 0) {
            // T·∫°o l·ªëi ƒëi n·ªëi t·ª´ nh√°nh m·ªõi v√†o nh√°nh gi·∫£ kh√°c
            connectBranches(startX, startY, branchX, branchY);
            break;
        }
    }
}

function findOtherFakeBranches() {
    // Duy·ªát qua m√™ cung ƒë·ªÉ t√¨m c√°c nh√°nh gi·∫£ (c√°c √¥ c√≥ ch·ªâ 1 ƒë∆∞·ªùng ƒëi)
    let branches = [];
    for (let y = 0; y < maze.length; y++) {
        for (let x = 0; x < maze[y].length; x++) {
            if (maze[y][x] === 0 && countOpenNeighbors(x, y) === 1) {
                branches.push({ x, y });  // Th√™m nh√°nh gi·∫£ v√†o danh s√°ch
            }
        }
    }
    return branches;
}

function connectBranches(startX, startY, endX, endY) {
    // ƒê·ª•c t∆∞·ªùng t·∫°o l·ªëi ƒëi n·ªëi hai nh√°nh gi·∫£
    let dx = Math.sign(endX - startX);
    let dy = Math.sign(endY - startY);

    // Di chuy·ªÉn t·ª´ startX, startY ƒë·∫øn endX, endY v√† ƒë·ª•c t∆∞·ªùng
    let x = startX;
    let y = startY;

    while (x !== endX || y !== endY) {
         safeBreakWall(x, y); // ‚úÖ ƒë·ª•c an to√†n

        if (x !== endX) x += dx;
        if (y !== endY) y += dy;
    }
}

function connectFakeBranchToMainPath() {
    // L·∫•y ƒë∆∞·ªùng ch√≠nh t·ª´ player ‚Üí exit
    let path = getPathFromStartToExit();
    if (path.length < 4) return; // Qu√° ng·∫Øn th√¨ th√¥i

    // T√≠nh v·ªã tr√≠ 9/10 ƒëo·∫°n ƒë∆∞·ªùng ch√≠nh
    let endIdx = Math.floor(path.length * 9 / 10);  // Ch·ªâ l·∫•y 9/10 ƒë∆∞·ªùng ƒëi
    let targetPath = path.slice(0, endIdx);  // C·∫Øt ch·ªâ l·∫•y ƒëo·∫°n ƒë∆∞·ªùng n√†y

    // ƒê·ª•c t∆∞·ªùng t·ª´ c√°c ƒëi·ªÉm trong ƒëo·∫°n ƒë∆∞·ªùng ch√≠nh n√†y v√†o nh√°nh gi·∫£
    let neighbors = [[0, -1], [1, 0], [0, 1], [-1, 0]];
    let connectionsMade = 0;  // S·ªë l∆∞·ª£ng l·ªó ƒë√£ ƒë·ª•c
    let maxConnections = 20;  // Gi·ªõi h·∫°n s·ªë l·∫ßn ƒë·ª•c th√™m

    // Duy·ªát c√°c ƒëi·ªÉm tr√™n ƒëo·∫°n ƒë∆∞·ªùng ch√≠nh (t·ª´ start ƒë·∫øn 9/10 ƒë∆∞·ªùng t·ªõi exit)
    for (let p of targetPath) {
        // Duy·ªát c√°c √¥ xung quanh ƒëi·ªÉm hi·ªán t·∫°i
        for (let [dx, dy] of neighbors) {
            let nx = p.x + dx;
            let ny = p.y + dy;

            // Ki·ªÉm tra ƒëi·ªÅu ki·ªán:
            // - N·∫øu √¥ b√™n c·∫°nh l√† t∆∞·ªùng (1) v√† l√† nh√°nh gi·∫£ (dead-end)
            if (inBounds(nx, ny) && maze[ny][nx] === 1 && countOpenNeighbors(nx, ny) === 1) {
                // ƒê·ª•c t∆∞·ªùng t·∫°o l·ªëi ƒëi v√†o nh√°nh gi·∫£
               if(safeBreakWall(nx, ny, p.x, p.y)){
    connectionsMade++;
}

                if (connectionsMade >= maxConnections) return;  // ƒê·∫°t gi·ªõi h·∫°n, d·ª´ng l·∫°i

                break;  // ƒê·ª•c xong 1 √¥, ti·∫øp t·ª•c v·ªõi ƒëi·ªÉm ti·∫øp theo
            }
        }
    }
}

// H√†m ch√≠nh g·ªçi 2 h√†m tr√™n
function createFakeBranchAndConnect() {
    // T·∫°o nh√°nh gi·∫£ ·ªü g√≥c ph·∫£i d∆∞·ªõi Exit
    createFakeBranchNearExit();

    // K·∫øt n·ªëi nh√°nh gi·∫£ v√†o ƒë∆∞·ªùng ch√≠nh
    connectFakeBranchToMainPath();
}
//ƒêI N √î PH·∫¢I C√ì NG√É R·∫º
function ensureJunctionEveryNCells(){
    let path = getPathFromStartToExit();
    let straight = 0;

    let earlyEnd = Math.floor(path.length * 0.8); // üî• 4/5 ƒë∆∞·ªùng

    for(let i = 2; i < path.length - 2; i++){
        let p0 = path[i-2];
        let p1 = path[i-1];
        let p2 = path[i];

        let dx1 = p1.x - p0.x;
        let dy1 = p1.y - p0.y;
        let dx2 = p2.x - p1.x;
        let dy2 = p2.y - p1.y;

        // ch·ªâ t√≠nh ƒëi th·∫≥ng
        if(dx1 === dx2 && dy1 === dy2){
            straight++;
        } else {
            // ‚ùó ch·ªâ reset n·∫øu l√† ng√£ 3 th·∫≠t
            if(countOpenNeighbors(p1.x, p1.y) >= 3){
                straight = 0;
            }
        }

        // üî• QUY ƒê·ªäNH M·∫¨T ƒê·ªò
        let limit =
            (i < earlyEnd) ? 4 : 8; // ƒë·∫ßu d√†y ‚Äì cu·ªëi th∆∞a

        if(straight < limit) continue;

        // üî• √âP T·∫†O NG√É 3 TH·∫¨T
        for(let k = 0; k < 6; k++){
            if(forceCreateRealJunction(p1)) break;
        }

        straight = 0;
    }
}

function forceCreateRealJunction(p){
    for(let [dx,dy] of shuffle([[0,-1],[1,0],[0,1],[-1,0]])){
        let wx = p.x + dx;
        let wy = p.y + dy;

        if(!safeBreakWall(wx, wy, p.x, p.y)) continue;

        // üî• CH·ªà CH·∫§P NH·∫¨N NG√É 3 TH·∫¨T
        if(countOpenNeighbors(p.x, p.y) >= 3){
            return true;
        }
    }
    return false;
}

function safeBreakWall(wx, wy, fromX, fromY) {
    let dx = wx - fromX;
    let dy = wy - fromY;

    let ax = wx + dx; // √¥ b√™n c·∫°nh (ax, ay) ph·∫£i l√† ƒë∆∞·ªùng
    let ay = wy + dy;

    // 1Ô∏è‚É£ Ki·ªÉm tra xem √¥ ti·∫øp theo c√≥ trong ph·∫°m vi kh√¥ng
    if (!inBounds(ax, ay)) return false;

    // 2Ô∏è‚É£ Ki·ªÉm tra √¥ t∆∞·ªùng h·ª£p l·ªá (wx, wy ph·∫£i l√† t∆∞·ªùng)
    if (maze[wy][wx] !== 1) return false;

    // 3Ô∏è‚É£ B√™n kia PH·∫¢I l√† ƒë∆∞·ªùng (ax, ay ph·∫£i l√† ƒë∆∞·ªùng)
    if (maze[ay][ax] !== 0) return false;

    // 4Ô∏è‚É£ Ki·ªÉm tra xem c√≥ ph·∫£i ng√£ ba/ng√£ b·ªën gi·∫£ kh√¥ng
    if (countOpenNeighbors(wx, wy) > 0) return false;

    // 5Ô∏è‚É£ Ki·ªÉm tra xem sau khi ƒë·ª•c t∆∞·ªùng, √¥ from ph·∫£i th√†nh junction th·∫≠t
    if (countOpenNeighbors(fromX, fromY) < 2) return false;

    // 6Ô∏è‚É£ Ki·ªÉm tra kh√¥ng t·∫°o h√†nh lang r·ªông
    if (wouldCreateWidePath(wx, wy)) return false;

    // 7Ô∏è‚É£ Tr√°nh ƒë·ª•c nh√°nh gi·∫£/c·ª•t g·∫ßn Exit
    if (isFakeDeadEndNearExit(wx, wy)) {
        return false; // N·∫øu nh√°nh gi·∫£/c·ª•t qu√° g·∫ßn exit, b·ªè qua
    }

    // **Ki·ªÉm tra l·∫°i sau khi ƒë·ª•c t∆∞·ªùng**:
    // Sau khi ƒë·ª•c t∆∞·ªùng, ki·ªÉm tra xem √¥ li·ªÅn k·ªÅ c√≥ ph·∫£i l√† ƒë∆∞·ªùng kh√¥ng
    if (checkAdjacentPaths(wx, wy)) {
        return false; // N·∫øu c√≥ √¥ ƒë∆∞·ªùng li·ªÅn k·ªÅ, kh√¥ng ƒë·ª•c
    }

    // N·∫øu t·∫•t c·∫£ c√°c ƒëi·ªÅu ki·ªán tr√™n ƒë·ªÅu th·ªèa m√£n, ƒë·ª•c t∆∞·ªùng
    maze[wy][wx] = 0; // ƒê·ª•c t∆∞·ªùng t·∫°i (wx, wy)

    return true;
}

// Ki·ªÉm tra xem nh√°nh gi·∫£/c·ª•t c√≥ qu√° g·∫ßn exit kh√¥ng
function isFakeDeadEndNearExit(wx, wy) {
    let distToExit = Math.abs(wx - exit.x) + Math.abs(wy - exit.y);

    // N·∫øu nh√°nh gi·∫£/c·ª•t n·∫±m trong b√°n k√≠nh 6 √¥ g·∫ßn exit, b·ªè qua
    if (distToExit <= 6) {
        return true; // Tr√°nh t·∫°o nh√°nh gi·∫£/c·ª•t qu√° g·∫ßn exit
    }
    return false;
}

// H√†m ki·ªÉm tra c√°c √¥ li·ªÅn k·ªÅ c√≥ ph·∫£i l√† ƒë∆∞·ªùng hay kh√¥ng
function checkAdjacentPaths(wx, wy) {
    // Ki·ªÉm tra c√°c √¥ xung quanh (li·ªÅn k·ªÅ) n·∫øu c√≥ ph·∫£i l√† ƒë∆∞·ªùng
    if (maze[wy][wx + 1] === 0 || maze[wy][wx - 1] === 0 || maze[wy + 1][wx] === 0 || maze[wy - 1][wx] === 0) {
        return true; // C√≥ √¥ ƒë∆∞·ªùng li·ªÅn k·ªÅ, n√™n kh√¥ng ƒë·ª•c
    }
    return false;
}

function wouldCreateWidePath(x, y){
    // ki·ªÉm tra block 2x2 quanh (x,y)
    const checks = [
        [[0,0],[1,0],[0,1],[1,1]],
        [[0,0],[-1,0],[0,1],[-1,1]],
        [[0,0],[1,0],[0,-1],[1,-1]],
        [[0,0],[-1,0],[0,-1],[-1,-1]],
    ];

    for(let block of checks){
        let open = 0;
        for(let [dx,dy] of block){
            let nx = x + dx;
            let ny = y + dy;
            if(inBounds(nx,ny) && maze[ny][nx] === 0){
                open++;
            }
        }
        if(open >= 3) return true; // t·∫°o h√†nh lang 2 √¥
    }
    return false;
}
function enforceSingleExitEntrance(){
    let opens = [];

    for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
        let nx = exit.x + dx;
        let ny = exit.y + dy;
        if(inBounds(nx,ny) && maze[ny][nx] === 0){
            opens.push({x:nx,y:ny});
        }
    }

    // ch·ªâ gi·ªØ l·∫°i 1 l·ªëi v√†o, c√≤n l·∫°i b·ªãt l·∫°i
    while(opens.length > 1){
        let c = opens.pop();
        maze[c.y][c.x] = 1;
    }
}
function getDeadEndDepth(x,y){
    let depth = 0;
    let px = x, py = y;
    let prev = null;

    while(true){
        let next = null;
        for(let [dx,dy] of [[0,-1],[1,0],[0,1],[-1,0]]){
            let nx = px+dx, ny = py+dy;
            if(!inBounds(nx,ny)) continue;
            if(maze[ny][nx]!==0) continue;
            if(prev && nx===prev.x && ny===prev.y) continue;
            next = {x:nx,y:ny};
        }
        if(!next) break;
        prev = {x:px,y:py};
        px = next.x; py = next.y;
        depth++;
        if(depth > 10) break;
    }
    return depth;
}

    /* ===== DRAW ===== */
  function drawMaze(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // ===== HI·ªÇN TH·ªä TO√ÄN B·ªò MAP =====
    if(revealAll){
        for(let y=0; y<ROWS; y++){
            for(let x=0; x<COLS; x++){
                ctx.fillStyle = maze[y][x]===1 ? "#000" : "#fff";
                ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
            }
        }
    } 
    // ===== CH·∫æ ƒê·ªò ƒê√àN PIN =====
    else {
        ctx.fillStyle = "#000";
        ctx.fillRect(0,0,canvas.width,canvas.height);

        let px = player.x*TILE + TILE/2;
        let py = player.y*TILE + TILE/2;
        let flicker = 0.9 + Math.random()*0.1;
        let lightRadius = TILE*3*flicker;

        ctx.save();
        ctx.beginPath();
        ctx.arc(px, py, lightRadius, 0, Math.PI*2);
        ctx.clip();

        for(let y=0; y<ROWS; y++){
            for(let x=0; x<COLS; x++){
                ctx.fillStyle = maze[y][x]===1 ? "#000" : "#fff";
                ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
            }
        }
        ctx.restore();

        let light = ctx.createRadialGradient(
            px, py, TILE*1.2,
            px, py, lightRadius
        );
        light.addColorStop(0.45,"rgba(255,235,180,0.35)");
        light.addColorStop(1,"rgba(0,0,0,0.8)");
        ctx.fillStyle = light;
        ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // exit
    ctx.fillStyle="lime";
    ctx.beginPath();
    ctx.arc(exit.x*TILE+TILE/2, exit.y*TILE+TILE/2, TILE/2.5,0,Math.PI*2);
    ctx.fill();

    // player
    let px = player.x*TILE + TILE/2;
    let py = player.y*TILE + TILE/2;
    ctx.fillStyle = "#00ffd5";
    ctx.beginPath();
    ctx.arc(px, py, TILE/2.5,0,Math.PI*2);
    ctx.fill();
}
// ===== CHEAT PC: Ctrl + L =====
document.addEventListener("keydown", e => {
    if (e.ctrlKey && (e.key === "l" || e.key === "L")) {
        e.preventDefault(); // tr√°nh browser focus address bar
        revealAll = !revealAll;
        drawMaze();
        console.log("CHEAT PC: revealAll =", revealAll);
    }
});
// ===== CHEAT MOBILE: 3 tap g√≥c tr√™n tr√°i =====
let cheatTap = 0; // ƒê·∫øm s·ªë l·∫ßn tap
let cheatTimer = null; // L∆∞u timer ƒë·ªÉ reset khi kh√¥ng c√≥ h√†nh ƒë·ªông n√†o trong 600ms

canvas.addEventListener("click", e => {
    let rect = canvas.getBoundingClientRect();
    let x = e.clientX - rect.left; // L·∫•y t·ªça ƒë·ªô x c·ªßa ƒëi·ªÉm click
    let y = e.clientY - rect.top; // L·∫•y t·ªça ƒë·ªô y c·ªßa ƒëi·ªÉm click

    // Ki·ªÉm tra n·∫øu b·∫•m v√†o g√≥c tr√™n tr√°i (x < 50 v√† y < 50)
    if (x < 50 && y < 50) {
        cheatTap++; // TƒÉng b·ªô ƒë·∫øm khi b·∫•m v√†o g√≥c

        // Reset l·∫°i b·ªô ƒë·∫øm n·∫øu kh√¥ng b·∫•m trong kho·∫£ng th·ªùi gian 600ms
        if (cheatTimer) clearTimeout(cheatTimer); // N·∫øu timer c√≤n ƒëang ch·∫°y th√¨ d·ª´ng
        cheatTimer = setTimeout(() => cheatTap = 0, 600); // Reset l·∫°i cheatTap sau 600ms n·∫øu kh√¥ng c√≥ b·∫•m

        // N·∫øu b·∫•m 3 l·∫ßn, b·∫≠t ch·∫ø ƒë·ªô cheat (revealAll)
        if (cheatTap >= 3) {
            revealAll = !revealAll;  // ƒê·∫£o tr·∫°ng th√°i cheat
            drawMaze();  // V·∫Ω l·∫°i maze
            cheatTap = 0; // Reset b·ªô ƒë·∫øm sau khi k√≠ch ho·∫°t cheat
            console.log("CHEAT MOBILE: revealAll =", revealAll);
        }
    }
});

    /* ===== MOVE LOGIC ===== */
    function availableDirs(x,y){
        let dirs = [];
        if(y>0 && maze[y-1][x]===0) dirs.push([0,-1]);
        if(y<ROWS-1 && maze[y+1][x]===0) dirs.push([0,1]);
        if(x>0 && maze[y][x-1]===0) dirs.push([-1,0]);
        if(x<COLS-1 && maze[y][x+1]===0) dirs.push([1,0]);
        return dirs;
    }

    function move(dx,dy){
        // B·∫Øt ƒë·∫ßu timer khi di chuy·ªÉn l·∫ßn ƒë·∫ßu
        if(!timerStarted){
            startTimer();
            timerStarted = true;
        }
        prevPos = {x:player.x, y:player.y};

        function step(){
            let nx = player.x + dx;
            let ny = player.y + dy;
            if(nx>=0 && nx<COLS && ny>=0 && ny<ROWS && maze[ny][nx]===0){
                player.x = nx;
                player.y = ny;
                drawMaze();

           if(player.x === exit.x && player.y === exit.y){
    revealAll = true;
    drawMaze();

    clearInterval(timerInterval);

    document.getElementById("winMessage").style.display = "block";

    setTimeout(()=>{
        window.location.href = "index.html";
    },15000);

    return;
}
                let dirs = availableDirs(player.x,player.y);
                if(dirs.length === 2){
                    setTimeout(step,70); // auto-move nhanh h∆°n
                }
            }
        }
        step();
    }

    /* ===== INPUT ===== */
    document.addEventListener("keydown", e=>{
        if(e.key==="ArrowUp") move(0,-1);
        if(e.key==="ArrowDown") move(0,1);
        if(e.key==="ArrowLeft") move(-1,0);
        if(e.key==="ArrowRight") move(1,0);
    });

document.getElementById("undoBtn").onclick = () => {
    player.x = 0;   // quay v·ªÅ xu·∫•t ph√°t
    player.y = 0;
    revealAll = false;  // reset ch·∫ø ƒë·ªô ƒë√®n pin n·∫øu ƒëang b·∫≠t
    drawMaze();

    // n·∫øu mu·ªën reset lu√¥n timer
    // clearInterval(timerInterval);
    // timerEl.textContent = "Time: 77 gi√¢y";
    // timerStarted = false;
};

    /* ===== TIMER ===== */
    function startTimer(){
        clearInterval(timerInterval);
        timeLeft = 90;
        timerEl.textContent = "Time: " + timeLeft+" gi√¢y";

        timerInterval = setInterval(()=>{
            timeLeft--;
            timerEl.textContent = "Time: " + timeLeft +" gi√¢y";
            if(timeLeft <= 0){
                clearInterval(timerInterval);
                showEndMessage();
            }
        },1000);
    }

function showEndMessage(){
    revealAll = true;
    drawMaze();

    document.getElementById("loseMessage").style.display = "block";

    setTimeout(()=>{
        document.getElementById("loseMessage").style.display = "none";
        revealAll = false;
        resetGame();
    },15000);
}


 /* ===== MOBILE TOUCH CONTROL ===== */
let touchStartX = 0, touchStartY = 0;
const SWIPE_MIN = 12;

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    let t = e.touches[0];
    touchStartX = t.clientX;
    touchStartY = t.clientY;
}, { passive: false });

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    let t = e.changedTouches[0];
    let dx = t.clientX - touchStartX;
    let dy = t.clientY - touchStartY;

    if(Math.abs(dx) > Math.abs(dy)){
        if(dx > SWIPE_MIN) move(1,0);
        else if(dx < -SWIPE_MIN) move(-1,0);
    } else {
        if(dy > SWIPE_MIN) move(0,1);
        else if(dy < -SWIPE_MIN) move(0,-1);
    }
}, { passive: false });

    /* ===== RESET GAME ===== */
 function resetGame(){
    revealAll = false;
    initMaze();
    player = {x:0, y:0};
    drawMaze();
    timerEl.textContent = "Time: 90 gi√¢y";
    timerStarted = false;
}

    /* ===== START ===== */
    resetGame();

     /* ===== N√∫t ƒëi·ªÅu khi·ªÉn ===== */
        document.getElementById("undoBtn").onclick = () => {
            player.x = 0;   // Quay v·ªÅ xu·∫•t ph√°t
            player.y = 0;
            revealAll = false;
            drawMaze();
        };

    // C√°c n√∫t di chuy·ªÉn
        document.getElementById("upBtn").onclick = () => {
            move(0, -1);
        };
        document.getElementById("downBtn").onclick = () => {
            move(0, 1);
        };
        document.getElementById("leftBtn").onclick = () => {
            move(-1, 0);
        };
        document.getElementById("rightBtn").onclick = () => {
            move(1, 0);
        };
    </script>
    </body>
    </html>
